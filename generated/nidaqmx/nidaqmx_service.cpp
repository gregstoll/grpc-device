
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-DAQMX Metadata
//---------------------------------------------------------------------
#include "nidaqmx_service.h"

#include <sstream>
#include <fstream>
#include <iostream>
#include <atomic>
#include <vector>

namespace nidaqmx_grpc {

  NiDAQmxService::NiDAQmxService(NiDAQmxLibraryInterface* library, ResourceRepositorySharedPtr session_repository)
      : library_(library), session_repository_(session_repository)
  {
  }

  NiDAQmxService::~NiDAQmxService()
  {
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateTask(::grpc::ServerContext* context, const CreateTaskRequest* request, CreateTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      const char* task_name = request->task_name().c_str();

      auto init_lambda = [&] () {
        TaskHandle task;
        int status = library_->CreateTask(task_name, &task);
        return std::make_tuple(status, task);
      };
      uint32_t session_id = 0;
      const std::string& grpc_device_session_name = request->session_name();
      auto cleanup_lambda = [&] (TaskHandle id) { library_->ClearTask(id); };
      int status = session_repository_->add_session(grpc_device_session_name, init_lambda, cleanup_lambda, session_id);
      response->set_status(status);
      if (status == 0) {
        response->mutable_task()->set_id(session_id);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ClearTask(::grpc::ServerContext* context, const ClearTaskRequest* request, ClearTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      session_repository_->remove_session(task);
      auto status = library_->ClearTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StartTask(::grpc::ServerContext* context, const StartTaskRequest* request, StartTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StartTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::StopTask(::grpc::ServerContext* context, const StopTaskRequest* request, StopTaskResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      auto status = library_->StopTask(task);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ExportSignal(::grpc::ServerContext* context, const ExportSignalRequest* request, ExportSignalResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 signal_id = request->signal_id();
      const char* output_terminal = request->output_terminal().c_str();
      auto status = library_->ExportSignal(task, signal_id, output_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetExtendedErrorInfo(::grpc::ServerContext* context, const GetExtendedErrorInfoRequest* request, GetExtendedErrorInfoResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      int32 buffer_size = request->buffer_size();
      std::string error_string;
      if (buffer_size > 0) {
          error_string.resize(buffer_size-1);
      }
      auto status = library_->GetExtendedErrorInfo((char*)error_string.data(), buffer_size);
      response->set_status(status);
      if (status == 0) {
        response->set_error_string(error_string);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ConnectTerms(::grpc::ServerContext* context, const ConnectTermsRequest* request, ConnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      const char* source_terminal = request->source_terminal().c_str();
      const char* destination_terminal = request->destination_terminal().c_str();
      int32 signal_modifiers = request->signal_modifiers();
      auto status = library_->ConnectTerms(source_terminal, destination_terminal, signal_modifiers);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::DisconnectTerms(::grpc::ServerContext* context, const DisconnectTermsRequest* request, DisconnectTermsResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      const char* source_terminal = request->source_terminal().c_str();
      const char* destination_terminal = request->destination_terminal().c_str();
      auto status = library_->DisconnectTerms(source_terminal, destination_terminal);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgDigEdgeStartTrig(::grpc::ServerContext* context, const CfgDigEdgeStartTrigRequest* request, CfgDigEdgeStartTrigResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* trigger_source = request->trigger_source().c_str();
      int32 trigger_edge = request->trigger_edge();
      auto status = library_->CfgDigEdgeStartTrig(task, trigger_source, trigger_edge);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateCIPulseChanFreq(::grpc::ServerContext* context, const CreateCIPulseChanFreqRequest* request, CreateCIPulseChanFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* counter = request->counter().c_str();
      const char* name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      double min_val = request->min_val();
      double max_val = request->max_val();
      int32 units = request->units();
      auto status = library_->CreateCIPulseChanFreq(task, counter, name_to_assign_to_channel, min_val, max_val, units);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreq(::grpc::ServerContext* context, const ReadCtrFreqRequest* request, ReadCtrFreqResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 interleaved = request->interleaved();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array_frequency()->Resize(array_size_in_samps, 0);
      float64* read_array_frequency = response->mutable_read_array_frequency()->mutable_data();
      response->mutable_read_array_duty_cycle()->Resize(array_size_in_samps, 0);
      float64* read_array_duty_cycle = response->mutable_read_array_duty_cycle()->mutable_data();
      int32 samps_per_chan_read {};
      auto status = library_->ReadCtrFreq(task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, array_size_in_samps, &samps_per_chan_read, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_read(samps_per_chan_read);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadCtrFreqStream(::grpc::ServerContext* context, const ReadCtrFreqStreamRequest* request, ::grpc::ServerWriter<ReadCtrFreqStreamResponse>* writer)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ReadCtrFreqStreamResponse localResponse;
      auto response = &localResponse;
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 interleaved = request->interleaved();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array_frequency()->Resize(array_size_in_samps, 0);
      float64* read_array_frequency = response->mutable_read_array_frequency()->mutable_data();
      response->mutable_read_array_duty_cycle()->Resize(array_size_in_samps, 0);
      float64* read_array_duty_cycle = response->mutable_read_array_duty_cycle()->mutable_data();
      int32 samps_per_chan_read {};
      do {
        auto status = library_->ReadCtrFreqStream(task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, array_size_in_samps, &samps_per_chan_read, reserved);
        response->set_status(status);
        if (status == 0) {
          response->set_samps_per_chan_read(samps_per_chan_read);
        }
      } while (writer->Write(localResponse));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAIVoltageChan(::grpc::ServerContext* context, const CreateAIVoltageChanRequest* request, CreateAIVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* physical_channel = request->physical_channel().c_str();
      const char* name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      int32 terminal_config = request->terminal_config();
      double min_val = request->min_val();
      double max_val = request->max_val();
      int32 units = request->units();
      const char* custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAIVoltageChan(task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateAOVoltageChan(::grpc::ServerContext* context, const CreateAOVoltageChanRequest* request, CreateAOVoltageChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* physical_channel = request->physical_channel().c_str();
      const char* name_to_assign_to_channel = request->name_to_assign_to_channel().c_str();
      double min_val = request->min_val();
      double max_val = request->max_val();
      int32 units = request->units();
      const char* custom_scale_name = request->custom_scale_name().c_str();
      auto status = library_->CreateAOVoltageChan(task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDIChan(::grpc::ServerContext* context, const CreateDIChanRequest* request, CreateDIChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* lines = request->lines().c_str();
      const char* name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping = request->line_grouping();
      auto status = library_->CreateDIChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CreateDOChan(::grpc::ServerContext* context, const CreateDOChanRequest* request, CreateDOChanResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* lines = request->lines().c_str();
      const char* name_to_assign_to_lines = request->name_to_assign_to_lines().c_str();
      int32 line_grouping = request->line_grouping();
      auto status = library_->CreateDOChan(task, lines, name_to_assign_to_lines, line_grouping);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeUInt32(::grpc::ServerContext* context, const GetChanAttributeUInt32Request* request, GetChanAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value {};
      auto status = library_->GetChanAttributeUInt32(task, channel, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeUInt32(::grpc::ServerContext* context, const SetChanAttributeUInt32Request* request, SetChanAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto status = library_->SetChanAttributeUInt32(task, channel, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeInt32(::grpc::ServerContext* context, const GetChanAttributeInt32Request* request, GetChanAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value {};
      auto status = library_->GetChanAttributeInt32(task, channel, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeInt32(::grpc::ServerContext* context, const SetChanAttributeInt32Request* request, SetChanAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value = request->value();
      auto status = library_->SetChanAttributeInt32(task, channel, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeDouble(::grpc::ServerContext* context, const GetChanAttributeDoubleRequest* request, GetChanAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value {};
      auto status = library_->GetChanAttributeDouble(task, channel, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeDouble(::grpc::ServerContext* context, const SetChanAttributeDoubleRequest* request, SetChanAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value = request->value();
      auto status = library_->SetChanAttributeDouble(task, channel, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetChanAttributeString(::grpc::ServerContext* context, const GetChanAttributeStringRequest* request, GetChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 size = request->size();
      std::string value;
      if (size > 0) {
          value.resize(size-1);
      }
      auto status = library_->GetChanAttributeString(task, channel, attribute, (char*)value.data(), size);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetChanAttributeString(::grpc::ServerContext* context, const SetChanAttributeStringRequest* request, SetChanAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* channel = request->channel().c_str();
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetChanAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      const char* value = request->value().c_str();
      auto status = library_->SetChanAttributeString(task, channel, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeUInt32(::grpc::ServerContext* context, const GetTimingAttributeUInt32Request* request, GetTimingAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value {};
      auto status = library_->GetTimingAttributeUInt32(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeUInt32(::grpc::ServerContext* context, const SetTimingAttributeUInt32Request* request, SetTimingAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto status = library_->SetTimingAttributeUInt32(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeInt32(::grpc::ServerContext* context, const GetTimingAttributeInt32Request* request, GetTimingAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value {};
      auto status = library_->GetTimingAttributeInt32(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeInt32(::grpc::ServerContext* context, const SetTimingAttributeInt32Request* request, SetTimingAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value = request->value();
      auto status = library_->SetTimingAttributeInt32(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeDouble(::grpc::ServerContext* context, const GetTimingAttributeDoubleRequest* request, GetTimingAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value {};
      auto status = library_->GetTimingAttributeDouble(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeDouble(::grpc::ServerContext* context, const SetTimingAttributeDoubleRequest* request, SetTimingAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value = request->value();
      auto status = library_->SetTimingAttributeDouble(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetTimingAttributeString(::grpc::ServerContext* context, const GetTimingAttributeStringRequest* request, GetTimingAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetTimingAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 size = request->size();
      std::string value;
      if (size > 0) {
          value.resize(size-1);
      }
      auto status = library_->GetTimingAttributeString(task, attribute, (char*)value.data(), size);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetTimingAttributeString(::grpc::ServerContext* context, const SetTimingAttributeStringRequest* request, SetTimingAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetTimingAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      const char* value = request->value().c_str();
      auto status = library_->SetTimingAttributeString(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeUInt32(::grpc::ServerContext* context, const GetRealTimeAttributeUInt32Request* request, GetRealTimeAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value {};
      auto status = library_->GetRealTimeAttributeUInt32(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeUInt32(::grpc::ServerContext* context, const SetRealTimeAttributeUInt32Request* request, SetRealTimeAttributeUInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeUInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      uInt32 value = request->value();
      auto status = library_->SetRealTimeAttributeUInt32(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeInt32(::grpc::ServerContext* context, const GetRealTimeAttributeInt32Request* request, GetRealTimeAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value {};
      auto status = library_->GetRealTimeAttributeInt32(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeInt32(::grpc::ServerContext* context, const SetRealTimeAttributeInt32Request* request, SetRealTimeAttributeInt32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeInt32Request::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 value = request->value();
      auto status = library_->SetRealTimeAttributeInt32(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeDouble(::grpc::ServerContext* context, const GetRealTimeAttributeDoubleRequest* request, GetRealTimeAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value {};
      auto status = library_->GetRealTimeAttributeDouble(task, attribute, &value);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeDouble(::grpc::ServerContext* context, const SetRealTimeAttributeDoubleRequest* request, SetRealTimeAttributeDoubleResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeDoubleRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeDoubleRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeDoubleRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      double value = request->value();
      auto status = library_->SetRealTimeAttributeDouble(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::GetRealTimeAttributeString(::grpc::ServerContext* context, const GetRealTimeAttributeStringRequest* request, GetRealTimeAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::GetRealTimeAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::GetRealTimeAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      int32 size = request->size();
      std::string value;
      if (size > 0) {
          value.resize(size-1);
      }
      auto status = library_->GetRealTimeAttributeString(task, attribute, (char*)value.data(), size);
      response->set_status(status);
      if (status == 0) {
        response->set_value(value);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::SetRealTimeAttributeString(::grpc::ServerContext* context, const SetRealTimeAttributeStringRequest* request, SetRealTimeAttributeStringResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 attribute;
      switch (request->attribute_enum_case()) {
        case nidaqmx_grpc::SetRealTimeAttributeStringRequest::AttributeEnumCase::kAttribute: {
          attribute = static_cast<int32>(request->attribute());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeStringRequest::AttributeEnumCase::kAttributeRaw: {
          attribute = static_cast<int32>(request->attribute_raw());
          break;
        }
        case nidaqmx_grpc::SetRealTimeAttributeStringRequest::AttributeEnumCase::ATTRIBUTE_ENUM_NOT_SET: {
          return ::grpc::Status(::grpc::INVALID_ARGUMENT, "The value for attribute was not specified or out of range");
          break;
        }
      }

      const char* value = request->value().c_str();
      auto status = library_->SetRealTimeAttributeString(task, attribute, value);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU32(::grpc::ServerContext* context, const ReadDigitalU32Request* request, ReadDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 fill_mode = request->fill_mode();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan {};
      auto status = library_->ReadDigitalU32(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan(samps_per_chan);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadDigitalU32Stream(::grpc::ServerContext* context, const ReadDigitalU32StreamRequest* request, ::grpc::ServerWriter<ReadDigitalU32StreamResponse>* writer)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ReadDigitalU32StreamResponse localResponse;
      auto response = &localResponse;
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 fill_mode = request->fill_mode();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      uInt32* read_array = reinterpret_cast<uInt32*>(response->mutable_read_array()->mutable_data());
      int32 samps_per_chan {};
      do {
        auto status = library_->ReadDigitalU32Stream(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan, reserved);
        response->set_status(status);
        if (status == 0) {
          response->set_samps_per_chan(samps_per_chan);
        }
      } while (writer->Write(localResponse));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteDigitalU32(::grpc::ServerContext* context, const WriteDigitalU32Request* request, WriteDigitalU32Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      int32 auto_start = request->auto_start();
      double timeout = request->timeout();
      int32 data_layout = request->data_layout();
      auto write_array = reinterpret_cast<const uInt32*>(request->write_array().data());
      bool32* reserved = nullptr;

      int32 samps_per_chan_written {};
      auto status = library_->WriteDigitalU32(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64(::grpc::ServerContext* context, const ReadAnalogF64Request* request, ReadAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 fill_mode = request->fill_mode();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan {};
      auto status = library_->ReadAnalogF64(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan(samps_per_chan);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::ReadAnalogF64StreamCodegen(::grpc::ServerContext* context, const ReadAnalogF64StreamCodegenRequest* request, ::grpc::ServerWriter<ReadAnalogF64StreamCodegenResponse>* writer)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      ReadAnalogF64StreamCodegenResponse localResponse;
      auto response = &localResponse;
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      double timeout = request->timeout();
      int32 fill_mode = request->fill_mode();
      uInt32 array_size_in_samps = request->array_size_in_samps();
      bool32* reserved = nullptr;

      response->mutable_read_array()->Resize(array_size_in_samps, 0);
      float64* read_array = response->mutable_read_array()->mutable_data();
      int32 samps_per_chan {};
      do {
        auto status = library_->ReadAnalogF64StreamCodegen(task, num_samps_per_chan, timeout, fill_mode, read_array, array_size_in_samps, &samps_per_chan, reserved);
        response->set_status(status);
        if (status == 0) {
          response->set_samps_per_chan(samps_per_chan);
        }
      } while (writer->Write(localResponse));
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::WriteAnalogF64(::grpc::ServerContext* context, const WriteAnalogF64Request* request, WriteAnalogF64Response* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      int32 num_samps_per_chan = request->num_samps_per_chan();
      int32 auto_start = request->auto_start();
      double timeout = request->timeout();
      int32 data_layout = request->data_layout();
      auto write_array = request->write_array().data();
      bool32* reserved = nullptr;

      int32 samps_per_chan_written {};
      auto status = library_->WriteAnalogF64(task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, &samps_per_chan_written, reserved);
      response->set_status(status);
      if (status == 0) {
        response->set_samps_per_chan_written(samps_per_chan_written);
      }
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

  //---------------------------------------------------------------------
  //---------------------------------------------------------------------
  ::grpc::Status NiDAQmxService::CfgSampClkTiming(::grpc::ServerContext* context, const CfgSampClkTimingRequest* request, CfgSampClkTimingResponse* response)
  {
    if (context->IsCancelled()) {
      return ::grpc::Status::CANCELLED;
    }
    try {
      auto task_grpc_session = request->task();
      auto task = session_repository_->access_session(task_grpc_session.id(), task_grpc_session.name());
      const char* source = request->source().c_str();
      double rate = request->rate();
      int32 active_edge = request->active_edge();
      int32 sample_mode = request->sample_mode();
      uInt64 samps_per_chan = request->samps_per_chan();
      auto status = library_->CfgSampClkTiming(task, source, rate, active_edge, sample_mode, samps_per_chan);
      response->set_status(status);
      return ::grpc::Status::OK;
    }
    catch (nidevice_grpc::LibraryLoadException& ex) {
      return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
    }
  }

} // namespace nidaqmx_grpc

