
//---------------------------------------------------------------------
// This file is automatically generated. All manual edits will be lost.
//---------------------------------------------------------------------
// Service implementation for the NI-XNET Metadata
//---------------------------------------------------------------------
#include "nixnet_service.h"

#include <atomic>
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>

namespace nixnet_grpc {

NiXnetService::NiXnetService(NiXnetLibraryInterface* library, nidevice_grpc::SessionRepository* session_repository)
    : library_(library), session_repository_(session_repository)
{
}

NiXnetService::~NiXnetService()
{
}

//---------------------------------------------------------------------
//---------------------------------------------------------------------
::grpc::Status NiXnetService::CreateSession(::grpc::ServerContext* context, const CreateSessionRequest* request, CreateSessionResponse* response)
{
  if (context->IsCancelled()) {
    return ::grpc::Status::CANCELLED;
  }
  try {
    const char* database_name = request->database_name().c_str();
    const char* cluster_name = request->cluster_name().c_str();
    const char* list = request->list().c_str();
    const char* interface_parameter = request->interface().c_str();
    u32 mode = request->mode();

    auto init_lambda = [&]() {
      nxSessionRef_t session;
      int status = library_->CreateSession(database_name, cluster_name, list, interface_parameter, mode, &session);
      return std::make_tuple(status, session);
    };
    uint32_t session_id = 0;
    const std::string& session_name = request->session_name();
    auto cleanup_lambda = [&](nxSessionRef_t id) { library_->Clear(id); };
    int status = session_repository_.add_session(session_name, init_lambda, cleanup_lambda, session_id);
    response->set_status(status);
    if (status == 0) {
      response->mutable_session()->set_id(session_id);
    }
    return ::grpc::Status::OK;
  }
  catch (nidevice_grpc::LibraryLoadException& ex) {
    return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
  }
}

//---------------------------------------------------------------------
//---------------------------------------------------------------------
::grpc::Status NiXnetService::Clear(::grpc::ServerContext* context, const ClearRequest* request, ClearResponse* response)
{
  if (context->IsCancelled()) {
    return ::grpc::Status::CANCELLED;
  }
  try {
    auto session_grpc_session = request->session();
    auto session = session_repository_.access_session(session_grpc_session.id(), session_grpc_session.name());
    auto status = library_->Clear(session);
    response->set_status(status);
    return ::grpc::Status::OK;
  }
  catch (nidevice_grpc::LibraryLoadException& ex) {
    return ::grpc::Status(::grpc::NOT_FOUND, ex.what());
  }
}

}  // namespace nixnet_grpc
